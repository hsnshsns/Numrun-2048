<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Jelly Run 2048 — Kids Color Edition</title>
  <style>
    html, body { margin:0; padding:0; height:100%; overflow:hidden; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial; }
    body {
      background: radial-gradient(1200px 700px at 50% 20%, #b9e6ff 0%, #87cefa 35%, #3b57ff 60%, #1a1d66 80%, #0a0920 100%);
    }
    #hud { position: fixed; top: 12px; left: 12px; color: #fff; z-index: 10; user-select: none; text-shadow: 0 2px 10px rgba(0,0,0,.35); }
    #hud .score { font-size: 30px; font-weight: 900; letter-spacing: 0.5px; }
    #hud .sub { opacity: 0.9; font-size: 12px; margin-top: 6px; }
    #centerMsg { position: fixed; inset: 0; display:flex; align-items:center; justify-content:center; color:#fff; pointer-events:none; font-size: 44px; font-weight: 900; text-shadow: 0 8px 40px rgba(0,0,0,0.65); opacity:0; transition:opacity .35s ease; }
    #ui { position: fixed; bottom: 16px; left:0; right:0; display:flex; justify-content:center; gap:16px; z-index: 10; }
    .btn { background: rgba(255,255,255,.14); color:#fff; border:1px solid rgba(255,255,255,.25); padding:16px 20px; border-radius: 16px; font-weight:900; backdrop-filter: blur(8px); -webkit-tap-highlight-color: transparent; box-shadow: 0 8px 24px rgba(0,0,0,.25); }
    .btn:active { transform: scale(0.97); }
    #startBar { position: fixed; top: 0; left:0; right:0; display:flex; gap:10px; justify-content:center; padding:10px; z-index: 11; }
    #startBtn { background:#ff6bd6; color:#fff; border:none; padding:10px 14px; border-radius:12px; font-weight:900; cursor:pointer; box-shadow:0 6px 20px rgba(255,107,214,.45); }
    #legend { position: fixed; right: 10px; top: 10px; color:#fff; font-size:12px; line-height:1.3; background: rgba(255,255,255,.08); border:1px solid rgba(255,255,255,.2); padding:10px; border-radius:12px; backdrop-filter: blur(6px); max-width: 160px; }
    #legend b { display:inline-block; min-width:42px; }
  </style>
</head>
<body>
  <div id="hud">
    <div class="score">Total: <span id="score">0</span></div>
    <div class="sub">모바일: ◀ ▶ / 데스크톱: ← → | 숫자 큐브를 먹으면 <b>총합</b>이 증가하고, 플레이어 큐브에 합계가 표시돼요!</div>
  </div>
  <div id="legend"></div>
  <div id="centerMsg">READY</div>
  <div id="startBar"><button id="startBtn">Start / Reset</button></div>
  <div id="ui">
    <button class="btn" id="leftBtn">◀</button>
    <button class="btn" id="rightBtn">▶</button>
  </div>

  <canvas id="c"></canvas>

  <script src="https://unpkg.com/three@0.160.0/build/three.min.js"></script>
  <script>
  const clamp = (v, a, b) => Math.max(a, Math.min(b, v));

  const canvas = document.getElementById('c');
  const renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: true });
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.setPixelRatio(Math.min(2, window.devicePixelRatio || 1));

  const scene = new THREE.Scene();

  const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 400);
  camera.position.set(0, 7, 13);
  camera.lookAt(0, 0, 0);

  const hemi = new THREE.HemisphereLight(0xfff6e8, 0x223377, 1.1);
  scene.add(hemi);
  const dir = new THREE.DirectionalLight(0xffffff, 1.0);
  dir.position.set(6, 12, 8);
  dir.castShadow = false;
  scene.add(dir);

  const groundGeo = new THREE.PlaneGeometry(200, 600, 1, 1);
  const groundMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
  const ground = new THREE.Mesh(groundGeo, groundMat);
  ground.rotation.x = -Math.PI/2;
  ground.position.z = -150;
  scene.add(ground);

  function makeRainbowTexture() {
    const w = 64, h = 1024;
    const cvs = document.createElement('canvas');
    cvs.width = w; cvs.height = h;
    const ctx = cvs.getContext('2d');
    const grad = ctx.createLinearGradient(0, 0, 0, h);
    const stops = [
      ['#ff2d55', 0], ['#ff9f0a', 0.16], ['#ffd60a', 0.32], ['#34c759', 0.48],
      ['#0fd6ff', 0.64], ['#3b57ff', 0.80], ['#bf5af2', 1]
    ];
    for (const [c, s] of stops) grad.addColorStop(s, c);
    ctx.fillStyle = grad; ctx.fillRect(0,0,w,h);

    ctx.strokeStyle = 'rgba(255,255,255,.75)';
    ctx.lineWidth = 6;
    for (let y=0; y<h; y+=80) { ctx.beginPath(); ctx.moveTo(8, y+20); ctx.lineTo(w-8, y+20); ctx.stroke(); }

    const tex = new THREE.CanvasTexture(cvs);
    tex.wrapS = THREE.RepeatWrapping;
    tex.wrapT = THREE.RepeatWrapping;
    tex.repeat.set(6, 1);
    tex.anisotropy = 8;
    return tex;
  }
  const groundTex = makeRainbowTexture();
  ground.material.map = groundTex; ground.material.needsUpdate = true;

  const starGeo = new THREE.BufferGeometry();
  const starCnt = 1000;
  const starPositions = new Float32Array(starCnt * 3);
  for (let i=0;i<starCnt;i++) {
    starPositions[i*3+0] = (Math.random()-0.5) * 120;
    starPositions[i*3+1] = Math.random() * 80 + 10;
    starPositions[i*3+2] = (Math.random()-0.5) * 200 - 50;
  }
  starGeo.setAttribute('position', new THREE.BufferAttribute(starPositions, 3));
  const starMat = new THREE.PointsMaterial({ color: 0xffffff, size: 0.8, sizeAttenuation: true, transparent: true, opacity: 0.9 });
  const stars = new THREE.Points(starGeo, starMat);
  scene.add(stars);

  const LANES = [-3.2, 0, 3.2];
  let currentLaneIdx = 1;
  let targetX = LANES[currentLaneIdx];

  const numberColors = new Map([
    [2, '#ff3b30'],
    [4, '#ffd60a'],
    [8, '#34c759'],
    [16, '#0a84ff'],
    [32, '#001f54'],
    [64, '#6f2dbd'],
    [128, '#ff8ad6'],
    [256, '#20c997'],
    [512, '#2ecc71'],
    [1024, '#ff1493'],
  ]);

  function colorForValue(n) {
    if (n === 2048) return 'rainbow';
    if (numberColors.has(n)) return numberColors.get(n);
    const p = Math.log2(n);
    const hue = (p * 32) % 360;
    return `hsl(${hue}, 90%, 55%)`;
  }

  function roundRect(ctx, x, y, w, h, r) {
    r = Math.min(r, w/2, h/2);
    ctx.beginPath();
    ctx.moveTo(x+r, y);
    ctx.arcTo(x+w, y,   x+w, y+h, r);
    ctx.arcTo(x+w, y+h, x,   y+h, r);
    ctx.arcTo(x,   y+h, x,   y,   r);
    ctx.arcTo(x,   y,   x+w, y,   r);
    ctx.closePath();
  }

  function makeCuteNumberTexture(text, fillStyle = '#ffffff') {
    const size = 512;
    const cvs = document.createElement('canvas');
    cvs.width = cvs.height = size;
    const ctx = cvs.getContext('2d');

    ctx.clearRect(0,0,size,size);
    ctx.shadowColor = 'rgba(0,0,0,0.2)';
    ctx.shadowBlur = 18;
    ctx.fillStyle = 'rgba(255,255,255,0.92)';
    roundRect(ctx, 16, 16, size-32, size-32, 56);
    ctx.fill();

    ctx.shadowBlur = 0;
    ctx.strokeStyle = 'rgba(0,0,0,0.08)';
    ctx.lineWidth = 8;
    roundRect(ctx, 16, 16, size-32, size-32, 56);
    ctx.stroke();

    ctx.font = '900 200px Fredoka, Nunito, system-ui, Segoe UI, Roboto';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';

    if (fillStyle === 'rainbow') {
      const grad = ctx.createLinearGradient(0, 0, size, 0);
      grad.addColorStop(0.00, '#ff2d55');
      grad.addColorStop(0.16, '#ff9f0a');
      grad.addColorStop(0.32, '#ffd60a');
      grad.addColorStop(0.48, '#34c759');
      grad.addColorStop(0.64, '#0fd6ff');
      grad.addColorStop(0.80, '#3b57ff');
      grad.addColorStop(1.00, '#bf5af2');
      ctx.fillStyle = grad;
    } else {
      ctx.fillStyle = fillStyle;
    }

    let f = 220;
    ctx.font = `900 ${f}px Fredoka, Nunito, system-ui`;
    while (ctx.measureText(text.toString()).width > size*0.82 && f > 80) {
      f -= 10; ctx.font = `900 ${f}px Fredoka, Nunito, system-ui`;
    }
    ctx.fillText(text.toString(), size/2, size/2);

    const tex = new THREE.CanvasTexture(cvs);
    tex.anisotropy = 8;
    return tex;
  }

  const playerGeo = new THREE.BoxGeometry(2.2, 2.2, 2.2);
  const playerMats = new Array(6).fill(null).map(()=> new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.35, metalness: 0.15 }));
  const player = new THREE.Mesh(playerGeo, playerMats);
  player.position.set(0, 1.2, 0);
  player.castShadow = true; scene.add(player);

  function updatePlayerTextureWithTotal(totalText) {
    const tex = makeCuteNumberTexture(totalText, 'rainbow');
    for (let i=0;i<6;i++) { player.material[i].map = tex; player.material[i].needsUpdate = true; }
  }

  const scoreEl = document.getElementById('score');
  let score = 0n;
  function setScore(v) {
    score = v;
    scoreEl.textContent = score.toString();
    updatePlayerTextureWithTotal(score.toString());
  }
  setScore(0n);

  const pickups = [];
  const cubeGeo = new THREE.BoxGeometry(2.1, 2.1, 2.1);

  function makePickupMaterial(n) {
    const style = (n === 2048) ? 'rainbow' : colorForValue(n);
    const tex = makeCuteNumberTexture(n.toString(), style);
    const mat = new THREE.MeshStandardMaterial({ map: tex, roughness: 0.35, metalness: 0.15 });
    return mat;
  }

  function nextValue() {
    const s = Number(score > 0n ? (score < 4096n ? score : 4096n) : 0n);
    const powBase = clamp(Math.floor( Math.log2(s + 64) ), 2, 16);
    const maxPow = Math.max(2, powBase);
    const options = [];
    for (let p=1; p<=maxPow; p++) options.push(2**p);
    const r = Math.random();
    let idx = Math.floor(Math.pow(r, 1.8) * options.length);
    idx = clamp(idx, 0, options.length-1);
    return options[idx];
  }

  function spawnPickup() {
    const laneX = LANES[Math.floor(Math.random()*LANES.length)];
    const zStart = -90;
    const n = nextValue();
    const mat = makePickupMaterial(n);
    const m = new THREE.Mesh(cubeGeo, mat);
    m.position.set(laneX, 1.1, zStart);
    m.userData = { value: BigInt(n), collected: false };
    scene.add(m);
    pickups.push(m);
  }

  function moveLeft(){ if (currentLaneIdx > 0) { currentLaneIdx--; targetX = LANES[currentLaneIdx]; } }
  function moveRight(){ if (currentLaneIdx < LANES.length-1) { currentLaneIdx++; targetX = LANES[currentLaneIdx]; } }

  window.addEventListener('keydown', (e)=>{
    if (!running) return;
    if (e.key === 'ArrowLeft' || e.key === 'a') moveLeft();
    if (e.key === 'ArrowRight' || e.key === 'd') moveRight();
  });

  document.getElementById('leftBtn').addEventListener('click', ()=>{ if(running) moveLeft(); });
  document.getElementById('rightBtn').addEventListener('click', ()=>{ if(running) moveRight(); });
  document.getElementById('startBtn').addEventListener('click', ()=> resetGame());

  const legendEl = document.getElementById('legend');
  const legendPairs = [2,4,8,16,32,64,128,256,512,1024,2048];
  legendEl.innerHTML = legendPairs.map(v=>{
    const c = (v===2048)? 'linear-gradient(90deg,#ff2d55,#ff9f0a,#ffd60a,#34c759,#0fd6ff,#3b57ff,#bf5af2)' : colorForValue(v);
    const sw = `<span style="display:inline-block;width:14px;height:14px;border-radius:4px;background:${c};vertical-align:middle;margin-right:6px;border:1px solid rgba(0,0,0,.15)"></span>`;
    return `${sw}<b>${v}</b>`;
  }).join('<br>');

  function intersects(a, b, radius = 1.7) {
    const dx = a.position.x - b.position.x;
    const dz = a.position.z - b.position.z;
    return (dx*dx + dz*dz) < (radius*radius);
  }

  let last = 0;
  let speed = 15;
  let spawnTimer = 0;
  let running = false;

  function resetGame() {
    pickups.forEach(p => scene.remove(p));
    pickups.length = 0;
    setScore(0n);
    speed = 14;
    spawnTimer = 0;
    currentLaneIdx = 1; targetX = LANES[currentLaneIdx];
    player.position.set(targetX, 1.2, 0);
    running = true;
    flashCenter('GO!');
  }

  function flashCenter(text) {
    const el = document.getElementById('centerMsg');
    el.textContent = text; el.style.opacity = 1;
    clearTimeout(flashCenter._t);
    flashCenter._t = setTimeout(()=>{ el.style.opacity = 0; }, 700);
  }

  function tick(t){
    const dt = Math.min(0.033, (t - last) / 1000 || 0);
    last = t;

    player.position.y = 1.2 + Math.sin(t*0.004)*0.08;
    player.rotation.y += dt * 0.7;

    if (running) {
      player.position.x += (targetX - player.position.x) * Math.min(1, dt*10);

      spawnTimer -= dt;
      if (spawnTimer <= 0) {
        spawnPickup();
        spawnTimer = Math.max(0.40, 1.05 - Math.min(1, Number(score)/2048) );
      }

      const rm = [];
      for (const p of pickups) {
        p.position.z += speed * dt;
        p.rotation.x += dt * 0.6;
        p.rotation.z += dt * 0.4;

        if (!p.userData.collected && intersects(player, p, 2.0)) {
          p.userData.collected = true;
          setScore(score + p.userData.value);
          flashCenter('+' + p.userData.value.toString());
          p.scale.set(1.3,1.3,1.3);
          rm.push(p);
        } else if (p.position.z > 14) {
          rm.push(p);
        }
      }
      for (const p of rm) {
        const i = pickups.indexOf(p); if (i!==-1) pickups.splice(i,1);
        scene.remove(p);
      }

      speed = Math.min(36, speed + dt * 0.22);

      ground.position.z += speed * dt * 0.7;
      if (ground.position.z > 0) ground.position.z = -150;

      stars.rotation.y += dt * 0.03;
    }

    renderer.render(scene, camera);
    requestAnimationFrame(tick);
  }
  requestAnimationFrame(tick);

  (function intro(){
    running = false;
    document.getElementById('centerMsg').textContent = 'READY';
    document.getElementById('centerMsg').style.opacity = 1;
  })();

  window.addEventListener('resize', ()=>{
    const w = window.innerWidth, h = window.innerHeight;
    renderer.setSize(w,h);
    camera.aspect = w/h; camera.updateProjectionMatrix();
  });
  </script>
</body>
</html>
